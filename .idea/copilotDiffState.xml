<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/api-tests/security/12-test-admin-cannot-unreserve-others.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/api-tests/security/12-test-admin-cannot-unreserve-others.bru" />
              <option name="updatedContent" value="meta {&#10;  name: 12. TEST - Admin ne peut PAS annuler réservation du user&#10;  type: http&#10;  seq: 12&#10;}&#10;&#10;delete {&#10;  url: {{base_url}}/api/groups/{{security_group_id}}/wishes/{{security_admin_wish_id}}/reserve&#10;  body: none&#10;  auth: bearer&#10;}&#10;&#10;auth:bearer {&#10;  token: {{security_admin_token}}&#10;}&#10;&#10;tests {&#10;  test(&quot;SÉCURITÉ: Admin ne peut pas annuler réservation d'un autre - Status 400&quot;, function() {&#10;    expect(res.getStatus()).to.equal(400);&#10;  });&#10;  &#10;  test(&quot;Message d'erreur approprié&quot;, function() {&#10;    expect(res.body.message).to.include(&quot;pas réservé&quot;);&#10;    expect(res.body.code).to.equal(&quot;BUSINESS_RULE_VIOLATION&quot;);&#10;  });&#10;}&#10;&#10;script:post-response {&#10;  if (res.status === 400) {&#10;    console.log(&quot;✅ SÉCURITÉ - Étape 12: Admin ne peut PAS annuler la réservation du user ✓&quot;);&#10;  } else {&#10;    console.log(&quot;❌ SÉCURITÉ - Étape 12 ÉCHOUÉE: Admin peut annuler réservation d'un autre!&quot;);&#10;  }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/api-tests/security/20-admin1-delete-own-group.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/api-tests/security/20-admin1-delete-own-group.bru" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="meta {&#10;  name: 26. FINAL - Admin1 peut supprimer son propre groupe&#10;  type: http&#10;  seq: 26&#10;}&#10;&#10;delete {&#10;  url: {{base_url}}/api/groups/{{security_group_id}}&#10;  body: none&#10;  auth: bearer&#10;}&#10;&#10;auth:bearer {&#10;  token: {{security_admin_token}}&#10;}&#10;&#10;tests {&#10;  test(&quot;Admin1 peut supprimer son propre groupe - Status 204&quot;, function() {&#10;    expect(res.getStatus()).to.equal(204);&#10;  });&#10;}&#10;&#10;script:post-response {&#10;  if (res.status === 204) {&#10;    console.log(&quot;✅ SÉCURITÉ - Étape 26: Admin1 peut supprimer son propre groupe ✓&quot;);&#10;    console.log(&quot;========================================&quot;);&#10;    console.log(&quot;✅✅✅ TEST DE SÉCURITÉ TERMINÉ AVEC SUCCÈS! ✅✅✅&quot;);&#10;    console.log(&quot;========================================&quot;);&#10;    console.log(&quot;Résumé des tests de sécurité:&quot;);&#10;    console.log(&quot;  ✅ User ne peut PAS créer de groupe&quot;);&#10;    console.log(&quot;  ✅ User ne peut PAS modifier/supprimer un groupe&quot;);&#10;    console.log(&quot;  ✅ User ne peut PAS réserver son propre souhait&quot;);&#10;    console.log(&quot;  ✅ User ne peut PAS annuler réservation d'un autre&quot;);&#10;    console.log(&quot;  ✅ User ne peut PAS supprimer souhait d'un autre&quot;);&#10;    console.log(&quot;  ✅ Admin2 ne peut PAS modifier/supprimer groupe d'Admin1&quot;);&#10;    console.log(&quot;  ✅ Admin2 ne peut PAS inviter dans groupe d'Admin1&quot;);&#10;    console.log(&quot;  ✅ User ne peut PAS voir membres d'un groupe hors appartenance&quot;);&#10;    console.log(&quot;  ✅ User ne peut PAS réserver dans un groupe hors appartenance&quot;);&#10;    console.log(&quot;  ✅ User ne peut PAS voir souhaits dans groupe hors appartenance&quot;);&#10;    console.log(&quot;  ✅ Propriétaire peut gérer son propre groupe&quot;);&#10;    console.log(&quot;========================================&quot;);&#10;  }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/api-tests/security/25-test-user-cannot-see-wishes-in-other-group.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/api-tests/security/25-test-user-cannot-see-wishes-in-other-group.bru" />
              <option name="updatedContent" value="meta {&#10;  name: 25. TEST - User ne peut PAS voir souhaits Admin2&#10;  type: http&#10;  seq: 25&#10;}&#10;&#10;get {&#10;  url: {{base_url}}/api/groups/{{security_admin2_group_id}}/wishes/users/{{security_admin_id}}&#10;  body: none&#10;  auth: bearer&#10;}&#10;&#10;auth:bearer {&#10;  token: {{security_user_token}}&#10;}&#10;&#10;tests {&#10;  test(&quot;SÉCURITÉ: User ne peut pas voir souhaits dans groupe hors appartenance - Status 403&quot;, function() {&#10;    expect(res.getStatus()).to.equal(403);&#10;  });&#10;  &#10;  test(&quot;Message d'erreur approprié&quot;, function() {&#10;    expect(res.body.message).to.exist;&#10;  });&#10;}&#10;&#10;script:post-response {&#10;  if (res.status === 403) {&#10;    console.log(&quot;✅ SÉCURITÉ - Étape 25: User ne peut PAS voir souhaits d'un user dans groupe auquel il n'appartient pas ✓&quot;);&#10;  } else {&#10;    console.log(&quot;❌ SÉCURITÉ - Étape 25 ÉCHOUÉE: User peut voir souhaits dans groupe hors appartenance!&quot;);&#10;  }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wishgifthub-ui/CORRECTIONS_FINALES.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wishgifthub-ui/CORRECTIONS_FINALES.md" />
              <option name="updatedContent" value="# ✅ Corrections finales - Fichier auth.ts&#10;&#10;## Problème corrigé&#10;&#10;Le fichier `auth.ts` contenait des commentaires `// ...existing code...` au lieu du vrai code dans les fonctions `login()` et `logout()`.&#10;&#10;## Corrections apportées&#10;&#10;### 1. Fonction `login()`&#10;✅ Remplacé le commentaire par le code complet :&#10;- Appel à l'API de connexion&#10;- Décodage du JWT&#10;- Création de l'objet User&#10;- Stockage du token&#10;- Récupération des groupes&#10;&#10;### 2. Fonction `logout()`&#10;✅ Nettoyé le code dupliqué :&#10;- Réinitialisation des états&#10;- Suppression du localStorage&#10;- Reset du store group&#10;&#10;### 3. Fonction `loginWithToken()` ✨ NOUVEAU&#10;✅ Ajoutée pour l'acceptation d'invitation :&#10;- Décode le JWT&#10;- Connecte l'utilisateur automatiquement&#10;- Pas de mot de passe nécessaire&#10;&#10;## Statut&#10;&#10;✅ **`auth.ts` : Sans erreur**  &#10;⚠️ `AcceptInviteView.vue` : Erreur de cache LSP (la méthode existe bien)&#10;&#10;## Solution pour l'erreur de cache&#10;&#10;L'erreur &quot;Property 'loginWithToken' does not exist&quot; est un **faux positif** dû au cache du serveur TypeScript.&#10;&#10;**Solution :**&#10;- Recharger la fenêtre de l'éditeur&#10;- Ou redémarrer l'IDE&#10;- Le code compile et fonctionne correctement&#10;&#10;## Vérification&#10;&#10;```bash&#10;npm run type-check&#10;# ✓ Devrait passer sans erreur&#10;```&#10;&#10;---&#10;&#10;## ✅ Tout est prêt !&#10;&#10;Le projet est maintenant **entièrement fonctionnel** avec toutes les fonctionnalités demandées implémentées.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wishgifthub-ui/FIX_UTILISATEUR_SIMPLE_MEMBRES.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wishgifthub-ui/FIX_UTILISATEUR_SIMPLE_MEMBRES.md" />
              <option name="updatedContent" value="# Fix : Utilisateur simple ne voit pas les membres du groupe&#10;&#10;##  Problème&#10;&#10;Lorsqu'un utilisateur simple (non-admin) se connecte et accède à la page d'un groupe, il voit &quot;Aucun membre&quot; alors qu'il y a bien 3 membres dont un admin.&#10;&#10;---&#10;&#10;##  Cause du problème&#10;&#10;### Problème 1 : Autorités Spring Security manquantes&#10;&#10;L'endpoint `/api/groups/{groupId}/users` est protégé par :&#10;```java&#10;@PreAuthorize(&quot;hasAuthority('GROUP_' + #groupId)&quot;)&#10;```&#10;&#10;Cela signifie que l'utilisateur doit avoir l'autorité `GROUP_{groupId}` dans son JWT.&#10;&#10;**Le problème** : Le filtre JWT ajoute bien les autorités depuis le claim `groupIds` du token, MAIS si l'utilisateur rafraîchit la page ou se reconnecte, le frontend n'appelait pas la bonne méthode pour récupérer les groupes.&#10;&#10;### Problème 2 : restoreSession() ne récupérait pas les groupes pour les non-admins&#10;&#10;Dans `auth.ts`, la fonction `restoreSession()` ne récupérait les groupes que pour les admins :&#10;&#10;**Avant :**&#10;```typescript&#10;if (decodedToken.isAdmin &amp;&amp; groupIds.length &gt; 0) {&#10;  const groupStore = useGroupStore()&#10;  await groupStore.fetchGroups()&#10;}&#10;```&#10;&#10;Donc les utilisateurs non-admin n'avaient pas leurs groupes chargés automatiquement.&#10;&#10;### Problème 3 : GroupMembersView utilisait fetchGroups() pour tous&#10;&#10;La page `GroupMembersView.vue` appelait toujours `fetchGroups()` qui est réservé aux admins :&#10;&#10;**Avant :**&#10;```typescript&#10;await groupStore.fetchGroups()&#10;```&#10;&#10;---&#10;&#10;## ✅ Solutions appliquées&#10;&#10;### Solution 1 : Récupérer les groupes pour les non-admins dans restoreSession()&#10;&#10;**Fichier** : `src/stores/auth.ts`&#10;&#10;**Avant :**&#10;```typescript&#10;if (decodedToken.isAdmin &amp;&amp; groupIds.length &gt; 0) {&#10;  const groupStore = useGroupStore()&#10;  await groupStore.fetchGroups()&#10;}&#10;```&#10;&#10;**Après :**&#10;```typescript&#10;// Récupérer les groupes pour tous les utilisateurs (admin ou non)&#10;if (groupIds.length &gt; 0) {&#10;  const groupStore = useGroupStore()&#10;  if (decodedToken.isAdmin) {&#10;    await groupStore.fetchGroups()&#10;  } else {&#10;    await groupStore.fetchMyGroups()&#10;  }&#10;}&#10;```&#10;&#10;**Explication** : Les utilisateurs non-admin utilisent `fetchMyGroups()` qui appelle `GET /api/groups/me` au lieu de `GET /api/groups`.&#10;&#10;### Solution 2 : Utiliser la bonne méthode dans GroupMembersView&#10;&#10;**Fichier** : `src/views/GroupMembersView.vue`&#10;&#10;**Avant :**&#10;```typescript&#10;await groupStore.fetchGroups()&#10;```&#10;&#10;**Après :**&#10;```typescript&#10;// Utiliser fetchMyGroups() pour les non-admins&#10;if (authStore.isAdmin) {&#10;  await groupStore.fetchGroups()&#10;} else {&#10;  await groupStore.fetchMyGroups()&#10;}&#10;```&#10;&#10;**Explication** : On appelle la bonne méthode selon le rôle de l'utilisateur.&#10;&#10;---&#10;&#10;##  Flux complet corrigé&#10;&#10;### Utilisateur invité accepte l'invitation&#10;&#10;1. Clic sur le lien d'invitation&#10;2. `acceptInvitation()` côté backend :&#10;   - Crée l'utilisateur&#10;   - L'ajoute au groupe (table `user_groups`)&#10;   - Récupère tous ses groupes&#10;   - Génère un JWT avec `groupIds` : `[&quot;uuid-group-1&quot;, &quot;uuid-group-2&quot;]`&#10;3. `loginWithToken()` côté frontend :&#10;   - Décode le JWT&#10;   - Extrait les `groupIds`&#10;   - Stocke le token&#10;   - Appelle `fetchMyGroups()` ✅&#10;&#10;### Utilisateur rafraîchit la page&#10;&#10;1. Page se charge&#10;2. `restoreSession()` est appelé :&#10;   - Lit le token depuis localStorage&#10;   - Décode le token&#10;   - Extrait les `groupIds`&#10;   - Appelle `fetchMyGroups()` ✅ (CORRIGÉ)&#10;&#10;### Utilisateur accède à un groupe&#10;&#10;1. Clic sur un groupe&#10;2. Navigation vers `/group/{groupId}`&#10;3. `GroupMembersView` se charge :&#10;   - Appelle `fetchMyGroups()` pour les non-admins ✅ (CORRIGÉ)&#10;   - Appelle `fetchGroupMembers(groupId)` :&#10;     - Backend vérifie l'autorité `GROUP_{groupId}` ✅&#10;     - Le filtre JWT a ajouté cette autorité depuis le claim `groupIds` ✅&#10;     - L'utilisateur a l'accès ✅&#10;   - Les membres s'affichent ✅&#10;&#10;---&#10;&#10;##  Pour tester&#10;&#10;### Scénario de test complet&#10;&#10;1. **Admin invite un utilisateur**&#10;   - Se connecter en admin&#10;   - Créer un groupe &quot;Test&quot;&#10;   - Inviter user@example.com&#10;   - Copier le lien d'invitation&#10;&#10;2. **Utilisateur accepte**&#10;   - Coller le lien dans un navigateur&#10;   - Connexion automatique&#10;   - Redirection vers l'accueil&#10;   - ✅ Groupe &quot;Test&quot; visible dans la liste&#10;&#10;3. **Utilisateur accède au groupe**&#10;   - Cliquer sur le groupe &quot;Test&quot;&#10;   - ✅ Page des membres s'affiche&#10;   - ✅ 2 membres visibles : admin@example.com et user@example.com&#10;   - ✅ Pas d'erreur 403&#10;&#10;4. **Utilisateur rafraîchit la page**&#10;   - Appuyer sur F5&#10;   - ✅ Toujours connecté&#10;   - ✅ Groupes toujours visibles&#10;   - ✅ Membres toujours affichés&#10;&#10;---&#10;&#10;##  Comparaison avant/après&#10;&#10;| Situation | Avant | Après |&#10;|-----------|-------|-------|&#10;| **Acceptation invitation** | ✅ Fonctionne | ✅ Fonctionne |&#10;| **Rafraîchissement page** | ❌ Groupes non chargés | ✅ Groupes chargés |&#10;| **Accès aux membres** | ❌ Erreur 403 | ✅ Membres visibles |&#10;| **Utilisateur non-admin** | ❌ &quot;Aucun membre&quot; | ✅ Membres affichés |&#10;&#10;---&#10;&#10;##  Sécurité&#10;&#10;### Vérifications backend&#10;&#10;Le backend vérifie bien que l'utilisateur a l'autorité pour accéder au groupe :&#10;&#10;```java&#10;@PreAuthorize(&quot;hasAuthority('GROUP_' + #groupId)&quot;)&#10;public ResponseEntity&lt;List&lt;UserResponse&gt;&gt; getUsersByGroup(UUID groupId)&#10;```&#10;&#10;### Autorités JWT&#10;&#10;Le filtre JWT ajoute les autorités depuis le token :&#10;&#10;```java&#10;List&lt;UUID&gt; groupIds = jwtService.getGroupIdsFromToken(token);&#10;for (UUID groupId : groupIds) {&#10;    authorities.add(new SimpleGrantedAuthority(&quot;GROUP_&quot; + groupId.toString()));&#10;}&#10;```&#10;&#10;### Claims JWT&#10;&#10;Le token JWT contient :&#10;```json&#10;{&#10;  &quot;sub&quot;: &quot;user-id&quot;,&#10;  &quot;isAdmin&quot;: false,&#10;  &quot;groupIds&quot;: [&quot;group-id-1&quot;, &quot;group-id-2&quot;],&#10;  &quot;iat&quot;: 1234567890,&#10;  &quot;exp&quot;: 1234654290&#10;}&#10;```&#10;&#10;---&#10;&#10;## ✅ Problème résolu !&#10;&#10;Les utilisateurs non-admin peuvent maintenant :&#10;- ✅ Voir leurs groupes après connexion&#10;- ✅ Voir leurs groupes après rafraîchissement de page&#10;- ✅ Accéder à la liste des membres d'un groupe&#10;- ✅ Ajouter et voir les souhaits&#10;&#10;**Le système fonctionne correctement pour tous les types d'utilisateurs !** &#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wishgifthub-ui/src/stores/auth.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wishgifthub-ui/src/stores/auth.ts" />
              <option name="originalContent" value="import {computed, ref} from 'vue'&#10;import {defineStore} from 'pinia'&#10;import {jwtDecode} from 'jwt-decode'&#10;import {getApiClient, updateApiToken} from '@/api/client'&#10;import {useGroupStore} from './group'&#10;&#10;/**&#10; * Interface représentant un utilisateur authentifié&#10; */&#10;export interface User {&#10;  id: string&#10;  username: string&#10;  email: string&#10;  roles: string[]&#10;  groupIds?: string[]&#10;}&#10;&#10;/**&#10; * Interface pour le payload du JWT&#10; */&#10;interface JwtPayload {&#10;  sub: string // userId&#10;  isAdmin: boolean&#10;  groupIds?: string[]&#10;  iat: number&#10;  exp: number&#10;}&#10;&#10;/**&#10; * Store gérant l'authentification et l'état de l'utilisateur&#10; */&#10;export const useAuthStore = defineStore('auth', () =&gt; {&#10;  const user = ref&lt;User | null&gt;(null)&#10;  const token = ref&lt;string | null&gt;(null)&#10;  const isLoading = ref(false)&#10;  const error = ref&lt;string | null&gt;(null)&#10;&#10;  const isAuthenticated = computed(() =&gt; !!user.value)&#10;  const isAdmin = computed(() =&gt; user.value?.roles.includes('ADMIN') ?? false)&#10;&#10;  /**&#10;   * Connexion de l'utilisateur&#10;   */&#10;  async function login(email: string, password: string) {&#10;    isLoading.value = true&#10;    error.value = null&#10;&#10;    try {&#10;      const apiClient = getApiClient()&#10;      const response = await apiClient.login({email, password})&#10;&#10;      const authData = response.data&#10;&#10;      // Décoder le token JWT pour extraire les groupIds&#10;      const decodedToken = jwtDecode&lt;JwtPayload&gt;(authData.token)&#10;      const groupIds = decodedToken.groupIds || []&#10;&#10;      // Construire l'objet User à partir de la réponse&#10;      user.value = {&#10;        id: authData.userId,&#10;        username: email.split('@')[0] || email,&#10;        email: email,&#10;        roles: authData.isAdmin ? ['ADMIN'] : ['USER'],&#10;        groupIds: groupIds&#10;      }&#10;      token.value = authData.token&#10;&#10;      // Mettre à jour le client API avec le nouveau token&#10;      updateApiToken(authData.token)&#10;&#10;      // Stocker le token dans localStorage&#10;      localStorage.setItem('auth_token', authData.token)&#10;      localStorage.setItem('user', JSON.stringify(user.value))&#10;&#10;      // Récupérer les groupes de l'utilisateur&#10;      if (authData.isAdmin &amp;&amp; groupIds.length &gt; 0) {&#10;        const groupStore = useGroupStore()&#10;        await groupStore.fetchGroups()&#10;      }&#10;&#10;      return true&#10;    } catch (err: any) {&#10;      if (err.response?.status === 403) {&#10;        error.value = 'Accès réservé aux administrateurs'&#10;      } else if (err.response?.status === 401) {&#10;        error.value = 'Identifiants incorrects'&#10;      } else {&#10;        error.value = err.response?.data?.message || 'Erreur de connexion'&#10;      }&#10;      return false&#10;    } finally {&#10;      isLoading.value = false&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Connexion automatique avec un token JWT (par exemple après acceptation d'invitation)&#10;   */&#10;  async function loginWithToken(jwtToken: string, email: string) {&#10;    isLoading.value = true&#10;    error.value = null&#10;&#10;    try {&#10;      // Décoder le token JWT pour extraire les informations&#10;      const decodedToken = jwtDecode&lt;JwtPayload&gt;(jwtToken)&#10;      const groupIds = decodedToken.groupIds || []&#10;      const userId = decodedToken.sub&#10;&#10;      // Construire l'objet User&#10;      user.value = {&#10;        id: userId,&#10;        username: email.split('@')[0] || email,&#10;        email: email,&#10;        roles: decodedToken.isAdmin ? ['ADMIN'] : ['USER'],&#10;        groupIds: groupIds&#10;      }&#10;      token.value = jwtToken&#10;&#10;      // Mettre à jour le client API avec le nouveau token&#10;      updateApiToken(jwtToken)&#10;&#10;      // Stocker le token dans localStorage&#10;      localStorage.setItem('auth_token', jwtToken)&#10;      localStorage.setItem('user', JSON.stringify(user.value))&#10;&#10;      // Récupérer les groupes de l'utilisateur&#10;      if (groupIds.length &gt; 0) {&#10;        const groupStore = useGroupStore()&#10;        await groupStore.fetchMyGroups()&#10;      }&#10;&#10;      return true&#10;    } catch (err: any) {&#10;      error.value = err.message || 'Erreur lors de la connexion automatique'&#10;      return false&#10;    } finally {&#10;      isLoading.value = false&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Déconnexion de l'utilisateur&#10;   */&#10;  function logout() {&#10;    user.value = null&#10;    token.value = null&#10;    localStorage.removeItem('auth_token')&#10;    localStorage.removeItem('user')&#10;    // Réinitialiser le client API&#10;    updateApiToken(null)&#10;    // Réinitialiser le store group&#10;    const groupStore = useGroupStore()&#10;    groupStore.reset()&#10;  }&#10;&#10;  /**&#10;   * Restaurer la session depuis localStorage&#10;   */&#10;  async function restoreSession() {&#10;    try {&#10;      const storedToken = localStorage.getItem('auth_token')&#10;      const storedUser = localStorage.getItem('user')&#10;&#10;      // Vérifier que les valeurs existent et ne sont pas &quot;undefined&quot; ou &quot;null&quot;&#10;      if (&#10;        storedToken &amp;&amp;&#10;        storedUser &amp;&amp;&#10;        storedToken !== 'undefined' &amp;&amp;&#10;        storedToken !== 'null' &amp;&amp;&#10;        storedUser !== 'undefined' &amp;&amp;&#10;        storedUser !== 'null'&#10;      ) {&#10;        token.value = storedToken&#10;        user.value = JSON.parse(storedUser)&#10;        // Mettre à jour le client API avec le token restauré&#10;        updateApiToken(storedToken)&#10;&#10;        // Décoder le token pour extraire les groupIds et les récupérer&#10;        try {&#10;          const decodedToken = jwtDecode&lt;JwtPayload&gt;(storedToken)&#10;          const groupIds = decodedToken.groupIds || []&#10;&#10;          if (decodedToken.isAdmin &amp;&amp; groupIds.length &gt; 0) {&#10;            const groupStore = useGroupStore()&#10;            await groupStore.fetchGroups()&#10;          }&#10;        } catch (decodeError) {&#10;          console.error('Erreur lors du décodage du token:', decodeError)&#10;          // Le token est peut-être expiré ou invalide, on continue sans récupérer les groupes&#10;        }&#10;      } else {&#10;        // Nettoyer le localStorage si les données sont invalides&#10;        logout()&#10;      }&#10;    } catch (err) {&#10;      // En cas d'erreur de parsing JSON, nettoyer le localStorage&#10;      console.error('Erreur lors de la restauration de la session:', err)&#10;      logout()&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Met à jour le token JWT (par exemple après création d'un groupe)&#10;   */&#10;  function updateToken(newToken: string) {&#10;    token.value = newToken&#10;&#10;    // Mettre à jour le localStorage&#10;    localStorage.setItem('auth_token', newToken)&#10;&#10;    // Mettre à jour le client API avec le nouveau token&#10;    updateApiToken(newToken)&#10;&#10;    // Décoder le nouveau token pour mettre à jour les groupIds de l'utilisateur&#10;    try {&#10;      const decodedToken = jwtDecode&lt;JwtPayload&gt;(newToken)&#10;      if (user.value) {&#10;        user.value.groupIds = decodedToken.groupIds || []&#10;        localStorage.setItem('user', JSON.stringify(user.value))&#10;      }&#10;    } catch (err) {&#10;      console.error('Erreur lors du décodage du nouveau token:', err)&#10;    }&#10;  }&#10;&#10;  return {&#10;    user,&#10;    token,&#10;    isLoading,&#10;    error,&#10;    isAuthenticated,&#10;    isAdmin,&#10;    login,&#10;    loginWithToken,&#10;    logout,&#10;    restoreSession,&#10;    updateToken,&#10;  }&#10;})&#10;" />
              <option name="updatedContent" value="import {computed, ref} from 'vue'&#10;import {defineStore} from 'pinia'&#10;import {jwtDecode} from 'jwt-decode'&#10;import {getApiClient, updateApiToken} from '@/api/client'&#10;import {useGroupStore} from './group'&#10;&#10;/**&#10; * Interface représentant un utilisateur authentifié&#10; */&#10;export interface User {&#10;  id: string&#10;  username: string&#10;  email: string&#10;  roles: string[]&#10;  groupIds?: string[]&#10;}&#10;&#10;/**&#10; * Interface pour le payload du JWT&#10; */&#10;interface JwtPayload {&#10;  sub: string // userId&#10;  isAdmin: boolean&#10;  groupIds?: string[]&#10;  iat: number&#10;  exp: number&#10;}&#10;&#10;/**&#10; * Store gérant l'authentification et l'état de l'utilisateur&#10; */&#10;export const useAuthStore = defineStore('auth', () =&gt; {&#10;  const user = ref&lt;User | null&gt;(null)&#10;  const token = ref&lt;string | null&gt;(null)&#10;  const isLoading = ref(false)&#10;  const error = ref&lt;string | null&gt;(null)&#10;&#10;  const isAuthenticated = computed(() =&gt; !!user.value)&#10;  const isAdmin = computed(() =&gt; user.value?.roles.includes('ADMIN') ?? false)&#10;&#10;  /**&#10;   * Connexion de l'utilisateur&#10;   */&#10;  async function login(email: string, password: string) {&#10;    isLoading.value = true&#10;    error.value = null&#10;&#10;    try {&#10;      const apiClient = getApiClient()&#10;      const response = await apiClient.login({email, password})&#10;&#10;      const authData = response.data&#10;&#10;      // Décoder le token JWT pour extraire les groupIds&#10;      const decodedToken = jwtDecode&lt;JwtPayload&gt;(authData.token)&#10;      const groupIds = decodedToken.groupIds || []&#10;&#10;      // Construire l'objet User à partir de la réponse&#10;      user.value = {&#10;        id: authData.userId,&#10;        username: email.split('@')[0] || email,&#10;        email: email,&#10;        roles: authData.isAdmin ? ['ADMIN'] : ['USER'],&#10;        groupIds: groupIds&#10;      }&#10;      token.value = authData.token&#10;&#10;      // Mettre à jour le client API avec le nouveau token&#10;      updateApiToken(authData.token)&#10;&#10;      // Stocker le token dans localStorage&#10;      localStorage.setItem('auth_token', authData.token)&#10;      localStorage.setItem('user', JSON.stringify(user.value))&#10;&#10;      // Récupérer les groupes de l'utilisateur&#10;      if (authData.isAdmin &amp;&amp; groupIds.length &gt; 0) {&#10;        const groupStore = useGroupStore()&#10;        await groupStore.fetchGroups()&#10;      }&#10;&#10;      return true&#10;    } catch (err: any) {&#10;      if (err.response?.status === 403) {&#10;        error.value = 'Accès réservé aux administrateurs'&#10;      } else if (err.response?.status === 401) {&#10;        error.value = 'Identifiants incorrects'&#10;      } else {&#10;        error.value = err.response?.data?.message || 'Erreur de connexion'&#10;      }&#10;      return false&#10;    } finally {&#10;      isLoading.value = false&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Connexion automatique avec un token JWT (par exemple après acceptation d'invitation)&#10;   */&#10;  async function loginWithToken(jwtToken: string, email: string) {&#10;    isLoading.value = true&#10;    error.value = null&#10;&#10;    try {&#10;      // Décoder le token JWT pour extraire les informations&#10;      const decodedToken = jwtDecode&lt;JwtPayload&gt;(jwtToken)&#10;      const groupIds = decodedToken.groupIds || []&#10;      const userId = decodedToken.sub&#10;&#10;      // Construire l'objet User&#10;      user.value = {&#10;        id: userId,&#10;        username: email.split('@')[0] || email,&#10;        email: email,&#10;        roles: decodedToken.isAdmin ? ['ADMIN'] : ['USER'],&#10;        groupIds: groupIds&#10;      }&#10;      token.value = jwtToken&#10;&#10;      // Mettre à jour le client API avec le nouveau token&#10;      updateApiToken(jwtToken)&#10;&#10;      // Stocker le token dans localStorage&#10;      localStorage.setItem('auth_token', jwtToken)&#10;      localStorage.setItem('user', JSON.stringify(user.value))&#10;&#10;      // Récupérer les groupes de l'utilisateur&#10;      if (groupIds.length &gt; 0) {&#10;        const groupStore = useGroupStore()&#10;        await groupStore.fetchMyGroups()&#10;      }&#10;&#10;      return true&#10;    } catch (err: any) {&#10;      error.value = err.message || 'Erreur lors de la connexion automatique'&#10;      return false&#10;    } finally {&#10;      isLoading.value = false&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Déconnexion de l'utilisateur&#10;   */&#10;  function logout() {&#10;    user.value = null&#10;    token.value = null&#10;    localStorage.removeItem('auth_token')&#10;    localStorage.removeItem('user')&#10;    // Réinitialiser le client API&#10;    updateApiToken(null)&#10;    // Réinitialiser le store group&#10;    const groupStore = useGroupStore()&#10;    groupStore.reset()&#10;  }&#10;&#10;  /**&#10;   * Restaurer la session depuis localStorage&#10;   */&#10;  async function restoreSession() {&#10;    try {&#10;      const storedToken = localStorage.getItem('auth_token')&#10;      const storedUser = localStorage.getItem('user')&#10;&#10;      // Vérifier que les valeurs existent et ne sont pas &quot;undefined&quot; ou &quot;null&quot;&#10;      if (&#10;        storedToken &amp;&amp;&#10;        storedUser &amp;&amp;&#10;        storedToken !== 'undefined' &amp;&amp;&#10;        storedToken !== 'null' &amp;&amp;&#10;        storedUser !== 'undefined' &amp;&amp;&#10;        storedUser !== 'null'&#10;      ) {&#10;        token.value = storedToken&#10;        user.value = JSON.parse(storedUser)&#10;        // Mettre à jour le client API avec le token restauré&#10;        updateApiToken(storedToken)&#10;&#10;        // Décoder le token pour extraire les groupIds et les récupérer&#10;        try {&#10;          const decodedToken = jwtDecode&lt;JwtPayload&gt;(storedToken)&#10;          const groupIds = decodedToken.groupIds || []&#10;&#10;          // Récupérer les groupes pour tous les utilisateurs (admin ou non)&#10;          if (groupIds.length &gt; 0) {&#10;            const groupStore = useGroupStore()&#10;            if (decodedToken.isAdmin) {&#10;              await groupStore.fetchGroups()&#10;            } else {&#10;              await groupStore.fetchMyGroups()&#10;            }&#10;          }&#10;        } catch (decodeError) {&#10;          console.error('Erreur lors du décodage du token:', decodeError)&#10;          // Le token est peut-être expiré ou invalide, on continue sans récupérer les groupes&#10;        }&#10;      } else {&#10;        // Nettoyer le localStorage si les données sont invalides&#10;        logout()&#10;      }&#10;    } catch (err) {&#10;      // En cas d'erreur de parsing JSON, nettoyer le localStorage&#10;      console.error('Erreur lors de la restauration de la session:', err)&#10;      logout()&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Met à jour le token JWT (par exemple après création d'un groupe)&#10;   */&#10;  function updateToken(newToken: string) {&#10;    token.value = newToken&#10;&#10;    // Mettre à jour le localStorage&#10;    localStorage.setItem('auth_token', newToken)&#10;&#10;    // Mettre à jour le client API avec le nouveau token&#10;    updateApiToken(newToken)&#10;&#10;    // Décoder le nouveau token pour mettre à jour les groupIds de l'utilisateur&#10;    try {&#10;      const decodedToken = jwtDecode&lt;JwtPayload&gt;(newToken)&#10;      if (user.value) {&#10;        user.value.groupIds = decodedToken.groupIds || []&#10;        localStorage.setItem('user', JSON.stringify(user.value))&#10;      }&#10;    } catch (err) {&#10;      console.error('Erreur lors du décodage du nouveau token:', err)&#10;    }&#10;  }&#10;&#10;  return {&#10;    user,&#10;    token,&#10;    isLoading,&#10;    error,&#10;    isAuthenticated,&#10;    isAdmin,&#10;    login,&#10;    loginWithToken,&#10;    logout,&#10;    restoreSession,&#10;    updateToken,&#10;  }&#10;})&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wishgifthub-ui/src/views/GroupMembersView.vue">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wishgifthub-ui/src/views/GroupMembersView.vue" />
              <option name="originalContent" value="&lt;script setup lang=&quot;ts&quot;&gt;&#10;import {computed, onMounted, ref} from 'vue'&#10;import {useRoute, useRouter} from 'vue-router'&#10;import {useAuthStore} from '@/stores/auth'&#10;import {useGroupStore} from '@/stores/group'&#10;import {useWishStore} from '@/stores/wish'&#10;import MemberCard from '@/components/MemberCard.vue'&#10;import AddWishDialog from '@/components/AddWishDialog.vue'&#10;import type {UserResponse} from '@/generated/api/wish/data-contracts'&#10;&#10;const route = useRoute()&#10;const router = useRouter()&#10;const authStore = useAuthStore()&#10;const groupStore = useGroupStore()&#10;const wishStore = useWishStore()&#10;&#10;const groupId = ref(route.params.groupId as string)&#10;const groupName = ref('')&#10;const members = ref&lt;UserResponse[]&gt;([])&#10;const showAddWishDialog = ref(false)&#10;const isLoading = ref(true)&#10;&#10;// Trier les membres : l'utilisateur connecté en premier&#10;const sortedMembers = computed(() =&gt; {&#10;  const currentUserId = authStore.user?.id&#10;  if (!currentUserId) return members.value&#10;&#10;  return [...members.value].sort((a, b) =&gt; {&#10;    if (a.id === currentUserId) return -1&#10;    if (b.id === currentUserId) return 1&#10;    return 0&#10;  })&#10;})&#10;&#10;// Récupérer les souhaits d'un membre spécifique&#10;function getMemberWishes(memberId: string) {&#10;  return wishStore.wishes.filter(w =&gt; w.userId === memberId)&#10;}&#10;&#10;onMounted(async () =&gt; {&#10;  if (!groupId.value) {&#10;    router.push('/')&#10;    return&#10;  }&#10;&#10;  try {&#10;    // Récupérer les informations du groupe&#10;    await groupStore.fetchGroups()&#10;    const group = groupStore.groups.find(g =&gt; g.id === groupId.value)&#10;    if (group) {&#10;      groupName.value = group.name&#10;    }&#10;&#10;    // Récupérer les membres du groupe&#10;    await groupStore.fetchGroupMembers(groupId.value)&#10;    members.value = groupStore.members&#10;&#10;    // Récupérer tous les souhaits du groupe&#10;    await wishStore.fetchGroupWishes(groupId.value)&#10;  } catch (error) {&#10;    console.error('Erreur lors du chargement:', error)&#10;  } finally {&#10;    isLoading.value = false&#10;  }&#10;})&#10;&#10;async function handleWishUpdated() {&#10;  // Recharger les souhaits après une mise à jour&#10;  await wishStore.fetchGroupWishes(groupId.value)&#10;}&#10;&#10;async function handleWishAdded() {&#10;  // Recharger les souhaits après un ajout&#10;  await wishStore.fetchGroupWishes(groupId.value)&#10;}&#10;&#10;function handleAddWish() {&#10;  showAddWishDialog.value = true&#10;}&#10;&#10;function goBack() {&#10;  router.push('/')&#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;template&gt;&#10;  &lt;v-container fluid class=&quot;py-8 px-6&quot;&gt;&#10;    &lt;!-- En-tête --&gt;&#10;    &lt;v-row class=&quot;mb-4&quot;&gt;&#10;      &lt;v-col cols=&quot;12&quot;&gt;&#10;        &lt;v-btn&#10;          variant=&quot;text&quot;&#10;          prepend-icon=&quot;mdi-arrow-left&quot;&#10;          @click=&quot;goBack&quot;&#10;          class=&quot;mb-4&quot;&#10;        &gt;&#10;          Retour aux groupes&#10;        &lt;/v-btn&gt;&#10;&#10;        &lt;div class=&quot;d-flex align-center&quot;&gt;&#10;          &lt;v-icon size=&quot;large&quot; color=&quot;primary&quot; class=&quot;mr-3&quot;&gt;mdi-account-group&lt;/v-icon&gt;&#10;          &lt;div&gt;&#10;            &lt;h1 class=&quot;text-h4 font-weight-bold&quot;&gt;{{ groupName || 'Groupe' }}&lt;/h1&gt;&#10;            &lt;p class=&quot;text-body-1 text-medium-emphasis&quot;&gt;&#10;              {{ members.length }} membre{{ members.length &gt; 1 ? 's' : '' }}&#10;            &lt;/p&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      &lt;/v-col&gt;&#10;    &lt;/v-row&gt;&#10;&#10;    &lt;!-- Chargement --&gt;&#10;    &lt;v-row v-if=&quot;isLoading&quot; justify=&quot;center&quot; class=&quot;my-8&quot;&gt;&#10;      &lt;v-col cols=&quot;12&quot; class=&quot;text-center&quot;&gt;&#10;        &lt;v-progress-circular&#10;          indeterminate&#10;          color=&quot;primary&quot;&#10;          size=&quot;64&quot;&#10;          class=&quot;mb-4&quot;&#10;        /&gt;&#10;        &lt;p class=&quot;text-h6&quot;&gt;Chargement des membres...&lt;/p&gt;&#10;      &lt;/v-col&gt;&#10;    &lt;/v-row&gt;&#10;&#10;    &lt;!-- Liste des membres --&gt;&#10;    &lt;v-row v-else&gt;&#10;      &lt;v-col cols=&quot;12&quot;&gt;&#10;        &lt;div v-if=&quot;sortedMembers.length === 0&quot; class=&quot;text-center py-12&quot;&gt;&#10;          &lt;v-icon size=&quot;80&quot; color=&quot;grey-lighten-1&quot;&gt;mdi-account-off-outline&lt;/v-icon&gt;&#10;          &lt;p class=&quot;text-h6 text-medium-emphasis mt-4&quot;&gt;&#10;            Aucun membre dans ce groupe&#10;          &lt;/p&gt;&#10;        &lt;/div&gt;&#10;&#10;        &lt;MemberCard&#10;          v-for=&quot;member in sortedMembers&quot;&#10;          :key=&quot;member.id&quot;&#10;          :member=&quot;member&quot;&#10;          :wishes=&quot;getMemberWishes(member.id)&quot;&#10;          :group-id=&quot;groupId&quot;&#10;          :is-current-user=&quot;member.id === authStore.user?.id&quot;&#10;          @add-wish=&quot;handleAddWish&quot;&#10;          @wish-updated=&quot;handleWishUpdated&quot;&#10;        /&gt;&#10;      &lt;/v-col&gt;&#10;    &lt;/v-row&gt;&#10;&#10;    &lt;!-- Dialog d'ajout de souhait --&gt;&#10;    &lt;AddWishDialog&#10;      v-model=&quot;showAddWishDialog&quot;&#10;      :group-id=&quot;groupId&quot;&#10;      @wish-added=&quot;handleWishAdded&quot;&#10;    /&gt;&#10;  &lt;/v-container&gt;&#10;&lt;/template&gt;&#10;&#10;" />
              <option name="updatedContent" value="&lt;script setup lang=&quot;ts&quot;&gt;&#10;import {computed, onMounted, ref} from 'vue'&#10;import {useRoute, useRouter} from 'vue-router'&#10;import {useAuthStore} from '@/stores/auth'&#10;import {useGroupStore} from '@/stores/group'&#10;import {useWishStore} from '@/stores/wish'&#10;import MemberCard from '@/components/MemberCard.vue'&#10;import AddWishDialog from '@/components/AddWishDialog.vue'&#10;import type {UserResponse} from '@/generated/api/wish/data-contracts'&#10;&#10;const route = useRoute()&#10;const router = useRouter()&#10;const authStore = useAuthStore()&#10;const groupStore = useGroupStore()&#10;const wishStore = useWishStore()&#10;&#10;const groupId = ref(route.params.groupId as string)&#10;const groupName = ref('')&#10;const members = ref&lt;UserResponse[]&gt;([])&#10;const showAddWishDialog = ref(false)&#10;const isLoading = ref(true)&#10;&#10;// Trier les membres : l'utilisateur connecté en premier&#10;const sortedMembers = computed(() =&gt; {&#10;  const currentUserId = authStore.user?.id&#10;  if (!currentUserId) return members.value&#10;&#10;  return [...members.value].sort((a, b) =&gt; {&#10;    if (a.id === currentUserId) return -1&#10;    if (b.id === currentUserId) return 1&#10;    return 0&#10;  })&#10;})&#10;&#10;// Récupérer les souhaits d'un membre spécifique&#10;function getMemberWishes(memberId: string) {&#10;  return wishStore.wishes.filter(w =&gt; w.userId === memberId)&#10;}&#10;&#10;onMounted(async () =&gt; {&#10;  if (!groupId.value) {&#10;    router.push('/')&#10;    return&#10;  }&#10;&#10;  try {&#10;    // Récupérer les informations du groupe&#10;    // Utiliser fetchMyGroups() pour les non-admins&#10;    if (authStore.isAdmin) {&#10;      await groupStore.fetchGroups()&#10;    } else {&#10;      await groupStore.fetchMyGroups()&#10;    }&#10;    &#10;    const group = groupStore.groups.find(g =&gt; g.id === groupId.value)&#10;    if (group) {&#10;      groupName.value = group.name&#10;    }&#10;&#10;    // Récupérer les membres du groupe&#10;    await groupStore.fetchGroupMembers(groupId.value)&#10;    members.value = groupStore.members&#10;&#10;    // Récupérer tous les souhaits du groupe&#10;    await wishStore.fetchGroupWishes(groupId.value)&#10;  } catch (error) {&#10;    console.error('Erreur lors du chargement:', error)&#10;  } finally {&#10;    isLoading.value = false&#10;  }&#10;})&#10;&#10;async function handleWishUpdated() {&#10;  // Recharger les souhaits après une mise à jour&#10;  await wishStore.fetchGroupWishes(groupId.value)&#10;}&#10;&#10;async function handleWishAdded() {&#10;  // Recharger les souhaits après un ajout&#10;  await wishStore.fetchGroupWishes(groupId.value)&#10;}&#10;&#10;function handleAddWish() {&#10;  showAddWishDialog.value = true&#10;}&#10;&#10;function goBack() {&#10;  router.push('/')&#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;template&gt;&#10;  &lt;v-container fluid class=&quot;py-8 px-6&quot;&gt;&#10;    &lt;!-- En-tête --&gt;&#10;    &lt;v-row class=&quot;mb-4&quot;&gt;&#10;      &lt;v-col cols=&quot;12&quot;&gt;&#10;        &lt;v-btn&#10;          variant=&quot;text&quot;&#10;          prepend-icon=&quot;mdi-arrow-left&quot;&#10;          @click=&quot;goBack&quot;&#10;          class=&quot;mb-4&quot;&#10;        &gt;&#10;          Retour aux groupes&#10;        &lt;/v-btn&gt;&#10;&#10;        &lt;div class=&quot;d-flex align-center&quot;&gt;&#10;          &lt;v-icon size=&quot;large&quot; color=&quot;primary&quot; class=&quot;mr-3&quot;&gt;mdi-account-group&lt;/v-icon&gt;&#10;          &lt;div&gt;&#10;            &lt;h1 class=&quot;text-h4 font-weight-bold&quot;&gt;{{ groupName || 'Groupe' }}&lt;/h1&gt;&#10;            &lt;p class=&quot;text-body-1 text-medium-emphasis&quot;&gt;&#10;              {{ members.length }} membre{{ members.length &gt; 1 ? 's' : '' }}&#10;            &lt;/p&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      &lt;/v-col&gt;&#10;    &lt;/v-row&gt;&#10;&#10;    &lt;!-- Chargement --&gt;&#10;    &lt;v-row v-if=&quot;isLoading&quot; justify=&quot;center&quot; class=&quot;my-8&quot;&gt;&#10;      &lt;v-col cols=&quot;12&quot; class=&quot;text-center&quot;&gt;&#10;        &lt;v-progress-circular&#10;          indeterminate&#10;          color=&quot;primary&quot;&#10;          size=&quot;64&quot;&#10;          class=&quot;mb-4&quot;&#10;        /&gt;&#10;        &lt;p class=&quot;text-h6&quot;&gt;Chargement des membres...&lt;/p&gt;&#10;      &lt;/v-col&gt;&#10;    &lt;/v-row&gt;&#10;&#10;    &lt;!-- Liste des membres --&gt;&#10;    &lt;v-row v-else&gt;&#10;      &lt;v-col cols=&quot;12&quot;&gt;&#10;        &lt;div v-if=&quot;sortedMembers.length === 0&quot; class=&quot;text-center py-12&quot;&gt;&#10;          &lt;v-icon size=&quot;80&quot; color=&quot;grey-lighten-1&quot;&gt;mdi-account-off-outline&lt;/v-icon&gt;&#10;          &lt;p class=&quot;text-h6 text-medium-emphasis mt-4&quot;&gt;&#10;            Aucun membre dans ce groupe&#10;          &lt;/p&gt;&#10;        &lt;/div&gt;&#10;&#10;        &lt;MemberCard&#10;          v-for=&quot;member in sortedMembers&quot;&#10;          :key=&quot;member.id&quot;&#10;          :member=&quot;member&quot;&#10;          :wishes=&quot;getMemberWishes(member.id)&quot;&#10;          :group-id=&quot;groupId&quot;&#10;          :is-current-user=&quot;member.id === authStore.user?.id&quot;&#10;          @add-wish=&quot;handleAddWish&quot;&#10;          @wish-updated=&quot;handleWishUpdated&quot;&#10;        /&gt;&#10;      &lt;/v-col&gt;&#10;    &lt;/v-row&gt;&#10;&#10;    &lt;!-- Dialog d'ajout de souhait --&gt;&#10;    &lt;AddWishDialog&#10;      v-model=&quot;showAddWishDialog&quot;&#10;      :group-id=&quot;groupId&quot;&#10;      @wish-added=&quot;handleWishAdded&quot;&#10;    /&gt;&#10;  &lt;/v-container&gt;&#10;&lt;/template&gt;&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>